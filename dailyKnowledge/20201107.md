# 20201107

### GC垃圾回收机制

 JVM的堆是Java对象的活动空间，程序中的类的对象从中分配空间，其存储着正在运行着的应用程序用到的所有对象。这些对象的建立方式就是那些new一类的操作，当对象无用后，是GC来负责这个无用的对象。

JVM堆包括：新域（Eden，2个辅助生存空间），旧域（一定次数GC循环后，对象被移入），永久域（类和方法对象，不回收）

**垃圾回收分为两个阶段：**

标记 --> 压缩标记的过程，其实就是判断对象是否可达的过程。当所有的根都检查完毕后，堆中将包含可达(已标记)与不可达(未标记)对象。标记完成后，进入压缩阶段。在这个阶段中，垃圾回收器线性的遍历堆，以寻找不可达对象的连续内存块。并把可达对象移动到这里以节约内存空间。

**垃圾回收的基本原理：**算法思路都是一致的：把所有对象组成一个集合，或可以理解为树状结构，从树根开始找，只要可以找到的都是活动对象，如果找不到，这个对象就被回收了**）

+ 垃圾回收器负责回收所有无任何引用对象的内存空间（JAVA中静态集合【Vector，Hashap等一直引用其中的对象】，连接【数据库，网络，I/O】没有close连接不会被回收，未被及时删除的监听器；它们不会被回收所以仍有可能导致出现内存泄露）。
+ 循环引用，网状结构等的实现会变得简单。GC的标志-压缩算法能有效的检测这些关系，并将不再被引用的网状结构整体删除。因为是从ROOT开始查

**常见算法**：

**Mark-Sweep** **标记清理算法**

阶段1: Mark-Sweep 标记清除阶段，先假设heap中所有对象都可以回收，然后找出不能回收的对象，给这些对象打上标记，最后heap中没有打标记的对象都是可以被回收的；

阶段2: Compact 压缩阶段，对象回收之后heap内存空间变得不连续，在heap中移动这些对象，使他们重新从heap基地址开始连续排列（节省内存资源）。

**复制算法**

新生代的内存被划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。每次回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。当Survivor空间不够用时，需要依赖老年代进行分配担保（Handle Promotion）。

**标记整理算法**

与标记清理算法过程一样，只是不直接清理可回收对象，而是将所有存活对象移动到一端，之后清理边界之外的对象内存

**分代收集算法**

 现代商用虚拟机基本都采用分代收集算法来进行垃圾回收。这种算法没什么特别的，无非是上面内容的结合罢了，根据对象的生命周期的不同将内存划分为几块，然后根据各块的特点采用最适当的收集算法。大批对象死去、少量对象存活的（新生代），使用复制算法，复制成本低；对象存活率高、没有额外空间进行分配担保的（老年代），采用标记-清理算法或者标记-整理算法。

***如何找到需要回收的对象***

1、引用计数法：给对象中添加一个引用计数器，每当一个地方引用这个对象时，计数器值+1；当引用失效时，计数器值-1。任何时刻计数值为0的对象就是不可能再被使用的。

2、可达性分析法:对于可达性分析算法而言，未到达的对象并非是“非死不可”的，若要宣判一个对象死亡，至少需要经历两次标记阶段。第一次finalize被调用被放到一个F-Queue的队列，一个优先级较低的Finalizer的线程处理该队列，二次标记调用finalizer如被引用则活，否则回收。

